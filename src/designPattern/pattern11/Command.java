package designPattern.pattern11;

/*
*	设计模式   笔记12
*	@author  zaichiyikoua
*	@time  2020年1月17日
*	@description  { 命令模式 }
*/

public class Command {
    // 命令模式(command pattern)，也是常用的行为型模式之一
    // 它将请求发送者与请求接收者解耦，请求发送者通过命令对象来间接地引用接收者
    // 可以在不修改源代码的情况下将相同的发送者对应不同的接收者，也可以组成宏命令
    // 其实就是将请求封装成一个对象，然后我们可以使用不同的请求对客户进行参数化
    // 举个例子更好理解:
    // 比如说电灯的开关和电灯，开关是请求的发送者，电灯是请求的接收者，他们之间不存在直接的耦合关系，而是通过电线来连接到一起的
    // 开关不需要直到如果开灯或者关灯请求传输给电灯，而是通过电线完成，可以理解为在电线中封装了开灯或者关灯请求。这样电线就充当了封装请求的对象
    // 开关如果开启，那么电线通电，调用开灯的方法。关灯也一样。不同的电线可以连接不同的电灯(连接不同的接收者)，只需要更换一根电线就可以让一个开关来控制不同的灯

    // 结构:1.抽象命令类 2.具体命令类 3.调用者 4.接收者 5.客户类
    // 命令模式使请求本身成为了一个对象，这个对象和其他对象一样可以被存储和传递。
    // 关键在于引入了抽象命令接口，并且发送者针对命令接口编程，只有实现了具体命令才能与接收者关联

    // 优点:
    // 1.降低了系统的耦合
    // 2.新的命令很容易增加，只要实现接口就可以了
    // 3.满足开闭原则，并且具有良好的灵活性和扩展性
    // 缺点:
    // 1.可能会导致某些系统具有过多的具体命令类

}
