### 线程池部分
#### 1.为什么要使用线程池？
线程是一种轻量级的工具，但是它的创建和关闭仍然需要花费大量的资源。如果为每一个小的任务都创建一个线程，那么很有可能出现创建和销毁线程所占用的时间大于该线程的任务执行时间。所以在实际的开发中，需要对线程的使用有所控制和管理。
##### 简而言之，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用，可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃

#### 2.线程池的原理？
回答这个问题，先看看线程池的构造参数：

1.corePoolSize：线程池核心线程数量

2.maximumPoolSize:线程池最大线程数量

3.keepAliverTime：当活跃线程数大于核心线程数时，空闲的多余线程最大存活时间

4.unit：存活时间的单位

5.workQueue：存放任务的队列

6.handler：超出线程范围和队列容量的任务的处理程序

这样的话就很明显了，1.线程池先判断池里的核心线程是否都在执行任务，如果不是(核心线程空闲或者还有核心线程没有被创建)，则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，那么进入下一个流程。

2.线程池判断工作队列是否已满，如果没有满，那么新提交的任务存在这个工作队列中。如果满了，进入下个流程。

3.判断线程池中的线程是否都处在工作状态，如果没有，那么创建一个新的工作线程来执行任务。如果满了，那么交给饱和策略来处理。

##### 简而言之，在创建新的线程线程的时候，判断核心线程数量，满了就不再创建新的线程，而是将任务加入工作队列，如果工作队列也满了，那么创建普通线程直到达到最大线程的数量，如果已经超过了最大线程数量，那么执行拒绝策略
#### 3.拒绝策略是什么？有哪些？
我们可以看到，线程池最后一个参数规定了拒绝策略，也就是说，当任务数量超过了系统实际的承载能力，就会用到拒绝策略。可以说是系统超负荷运行时的补救措施。

JDK内置了四种拒绝策略：

1.AbortPolicy:这种会直接抛异常，阻止系统工作

2.CallerRunsPolicy:只要线程池没有关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。

3.DiscardOldestPolicy:这种就是会丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务

4.DiscardPolicy:会默默地丢弃无法处理的任务，不予任何处理。