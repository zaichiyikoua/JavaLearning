package designPattern.pattern8;

/*
*	设计模式   笔记9
*	@author  zaichiyikoua
*	@time  2020年1月8日
*	@description  { 代理模式 }
*/

public class Proxy {
    // 代理模式(Proxy pattern)，给某个对象提供一个代理，并由代理对象控制对原来对象的引用
    // 在某些情况下，一个客户不能或者不想直接引用一个对象，此时可以通过一个代理的第三方来实现间接的引用
    // 比如说房屋中介，就是特别常见的代理。所谓代理，就是一个人或者一个机构代表另一个人或者机构采取行动
    // 也可以理解成中间层
    // 代理模式的结构比较简单，核心是代理类，代理类和实现类都会区实现相同的接口，然后由代理类去调用实现类

    // 结构:1.抽象主题角色 2.代理主题角色 3.真实主题角色

    // 优点:
    // 1.能够协调调用者和被调用者，一定程度上降低系统的耦合
    // 2.职责清晰
    // 3.扩展性强
    // 缺点:
    // 1.由于在客户端和真实主题之间添加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢
    // 2.实现代理模式需要额外的工作，有些代理模式的实现非常的复杂

    // ***代理模式非常重要***
    // case1:权限管理例子 --->>> 保护代理，可以控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限
    // case2:日记记录(也是SpringAOP类似的，因为AOP就是使用的动态代理)

    // 动态代理是一种较为高级的代理模式，典型应用就是SpringAOP
    // 传统的代理模式中，客户端通过代理对象来调用真实对象的方法，同时还会在代理类中封装其他的方法来处理其他问题
    // 但是如果按照这种方式，那么真实对象必须是事先已经存在的，并将其作为代理对象中的成员属性，这一点是必需的！！
    // 那么，如果一个真实对象对应一个代理类的话，这会导致系统中类的数量急剧增加
    // 动态代理就是在事先没有真实对象的情况下使用代理对象,能在不增加新的代理类的情况下，使得客户端动态选择所代理的真实对象
    // ***关键部分***
    // Java动态代理实现相关的类在反射包中，主要设计两个类
    // 1.InvocationHandler接口，这是代理实例的调用处理程序实现的接口
    // 主要方法是invoke，这个方法第一个参数是代理类，第二个参数是需要代理的方法，第三个参数是代理方法的参数列表(数组)
    // 2.Proxy类，这个类就是动态代理类，最常用的方法是newProxyInstance
    // 第一个参数是代理类的类加载器，第二个参数是代理类实现的接口列表(和真实对象的接口列表一致)，第三个参数是指派的调用处理程序类
}
