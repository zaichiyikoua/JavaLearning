### JVM部分
#### 首先大家从开始学java就讲过，java的跨平台是基于JVM的。JVM是java语言底层实现的基础。
#### 1.JVM的结构？
##### 1.1 堆
##### 这块区域是JVM所管理的内存中最大的一块。线程共享，主要用来存放对象实例和数组。官方说堆是运行时数据区域，所有类实例和数组的内存均从此处分配，并且在Java虚拟机启动时创建的。

##### 1.2 虚拟机栈(线程)
##### 线程私有，生命周期和线程一致。描述的是JAVA方法执行的内存模型:每个方法在执行的时候都会创建一个栈帧(stack frame)用来存储局部变量，操作数栈等信息。每一个方法从调用到执行结束，就对应着一个栈帧从JVM中入栈到出栈的过程。

##### 1.3 本地方法栈
##### 区别于虚拟机栈，虚拟机栈为虚拟机执行java方法服务，而本地方法栈为虚拟机使用的native方法服务(就是有native关键字修饰的方法，底层是C来实现的)。但是现在已经用的不多了

##### 1.4 方法区
##### 属于共享内存区域，用来存储被虚拟机加载的类信息，常量，静态变量等数据。

##### 1.5 程序计数器
##### 内存空间小，线程私有。保存虚拟机字节码指令的地址/undefine

#### 2.内存溢出和内存泄漏区别?
##### 内存溢出:程序在申请内存时，没有了足够的内存空间来供其使用
##### 内存泄露:程序在申请内存之后，无法是释放已经申请的内存空间。一次内存泄漏危害可以忽略，但是内存泄漏堆积的后果特别严重，无论内存有多大，最后都会被用光。

#### 3.JAVA的GC机制?
##### java中使用被称为垃圾回收器的机制来监视java程序的运行，当对象不再使用时，就自动释放对象所占用的内存空间，这个GC是自动运行的，一般情况下是不需要显式的请求。
##### java中没有规定GC如何工作，这是一个对立的线程，并且这个GC机制是为所有的java程序进程服务的，所以任何一个单个的进行都不能要求垃圾回收机制做什么、怎么做
##### 不要去假定垃圾回收发生的时间，这一切都是未知的。java中并不保证每次调用System.gc()方法就一定能启动垃圾回收器，这只是向JVM发出一个申请，但是是否真的能执行，是个未知数。

#### 4.常见内存泄漏的原因有哪些？
##### 1. 静态集合类
##### 像HashMap的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放
##### 2. 各种连接
##### 比如数据库连接，网络连接和IO连接，除非其显式的调用了其close()方法将其连接关闭，否则是不会自动被GC回收的。这点要养成好习惯，一定要记得关闭连接
##### 3. 内部类和外部模块的引用
##### 内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用
##### 4. 不正确地使用单例模式
##### 单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏